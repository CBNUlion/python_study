# 4장 파이 크러스트 : 코드 구조

> ### 파이썬 코드 구조화하기


## 4.1 코멘트 달기 : #

> '#' 문자를 이용하여 코멘트를 표시한다. 


## 4.2 라인 유지하기 : \

> 프로그램의 가독성을 위해, \ 문자를 이용하여 라인을 여러개로 나누어 작성한다.

## 4.3 비교하기 : if, elif, else

> 조건을 확인하는 파이썬의 선언문

### 4.3.1 True와 False

## 4.4 반복하기 : while

> 루핑 매커니즘

### 4.4.1 중단하기 : break

> 반복문에서 반복문을 종료하고 싶을 때 

### 4.4.2 건너뛰기 : continue

> 반복문에서 다음 루프로 건너뛰고 싶을 때 

### 4.4.3 break 확인하기 : else

> 반복문에서 break나 return 등 반복문을 종료하는 장치가 없으면 else가 실행된다. ( == break 체커)

## 4.5 순회하기 : for

> Iterable한 자료구조를 순회하는 반복문
> * C언어의 for문과 달리 여러 변수를 순회대상으로 설정할 수 있으며, 부수적인 변수 i를 사용하는 대신 필요한 변수 자체를 순회시킨다. *

### 4.5.1 중단하기 : break

> 반복문에서 반복문을 종료하고 싶을 때

### 4.5.2 건너뛰기 : continue

> 반복문에서 다음 루프로 건너뛰고 싶을 때 

### 4.5.3 break 확인하기 : else

> 반복문에서 break나 return 등 반복문을 종료하는 장치가 없으면 else가 실행된다. ( == break 체커)
> * 모든 예외 처리를 위해 해주는 것? *

### 4.5.4 여러 시퀀스 순회하기 : zip()

> for문에서 zip() 함수를 사용하여 여러 시퀀스를 병렬로 순회한다.

### 4.5.5 숫자 시퀀스 생성하기 : range()

> 특정 범위 내에서 자료구조를 생성하지 않고도 숫자 스트림을 반환한다.
> 컴퓨터 메모리를 전부 사용하지 않고, 프로그램 충돌 없이 큰 범위를 생성한다.

### 4.5.6 기타 이터레이터

> 직접 정의한 객체를 순회 가능하게 만들 수 있다.

## 4.6 컴프리핸션

> 하나 이상의 iterator로부터 파이썬의 자료구조를 만드는 콤팩트한 방법
> 반복문과 조건테스트를 결합할 수 있도록 해준다.

### 4.6.1 리스트 컴프리헨션

> ** [ 표현식 for 항목 in 순회가능한 객체 if 조건 ] **
> ** [ 표현식 for 항목 in 순회가능한 객체 for 항목 in 순회 가능한 객체 ] **

### 4.6.2 딕셔너리 컴프리헨션

> ** [ 키_표현식 : 값_표현식 for 표현식 in 순회 가능한 객체 ] **

### 4.6.3 셋 컴프리헨션

> ** [ 표현식 for 표현식 in 순회 가능한 객체 ] **

### 4.6.4 제너레이터 컴프리헨션

> ** [ 표현식 for 항목 in 순회가능한 객체 if 조건 ] **

## 4.7 함수

> 파이썬에서 함수를 사용하여 코드를 재사용 한다. 
> 모든 타입을 여러 개 입력받고, 모든 타입을 여러 개 반환한다.
>
> #### 정의하기
> def 함수 이름(입력 매개변수) :
>
> #### 호출하기
> 함수 이름(인자) :
> 
> 인자는 해당 입력 매개변수에 복사된다.

### 4.7.1 위치 인자

> 값을 입력받은 순서대로 상응하는 매개변수에 복사한다.
> 따라서, 각 위치의 의미를 아는 것이 중요하다.

### 4.7.2 키워드 인자

> 위치 인자의 혼동을 피하기 위해, 매개변수에 상응하는 이름을 인자에 넣어 지정할 수 있다.
> 위치 인자와 키워드 인자를 함수로 호출한다면 위치 인자가 먼저 와야 한다.

### 4.7.3 기본 매개변수값 지정하기

> 호출자가 대응하는 인자를 제공하지 않으면 기본값을 사용한다.
> *함수를 정의할 때 계산된다. 따라서 매개변수에 함수를 여러 번 실행한 값이 저장된다. (p.133 예제)*

### 4.7.4 위치 인자 모으기 : *

> 위치 인자 변수들을 튜플로 묶는다.
> *인자의 개수를 생각하지 않아도 된다.*

### 4.7.5 키워드 인자 모으기 : '**'

> 키워드 인자 변수들을 딕셔너리로 묶는다.
> *인자의 개수를 생각하지 않아도 된다.*
>
> #### 위치 매개변수, '*'arg, '**'kwargs 순서대로 배치한다.

### 4.7.6 docstring

> 함수의 가독성을 위해 함수 정의 몸체 시작 부분에 문자열을 포함시켜 함수 정의에 문서를 붙일 수 있다.
> 
> - help(함수이름)
> - print(함수이름.__doc__)
> 를 통해 확인할 수 있다.

### 4.7.7 일등 시민 : 함수

> 파이썬에서 함수는 객체이므로
> - 변수에 할당
> - 다른 함수에서 인자로 사용
> - 다른 함수에서 반환
> 할 수 있다.
> *이는 함수의 목적(코드의 재사용)을 완전완전 잘 달성할 수 있게 한다.*

### 4.7.8 내부 함수

> 함수 안에 다른 함수를 정의할 수 있다.
> 이는 루프나 코드 중복을 피할 때 유용하게 사용한다.

### 4.7.9 클로져

> 내부 함수는 클로져처럼 행동할 수 있다.
> 내부 함수가 포함된 함수에서 생성된 변수값을 변경하고, 저장한다.
> *__함수 외부 정의, 함수 내부 정의, 내부 함수 정의가 어떻게 다른지 더 볼 것!__*

### 4.7.10 익명 함수 : lambda()

> 단일문으로 표현되는 익명 함수다.
> 많은 작은 함수를 정의하고, 이들을 호출해서 얻은 결과값을 저장할 때 유용하다.
> ex> lambda word: word.capitalize()

## 4.8 제너레이터

> 파이썬의 시퀀스를 생성하는 객체
> 컴퓨터 메모리에 생성하고 정렬할 필요 없이 순회할 수 있게 한다.
> 일반 함수와 다르게 마지막으로 호출된 항목을 기억하고, 다음 값을 반환한다.
> (일반함수는 이전 호출에 대한 메모리가 없고, 항상 똑같은 상태로 첫 라인부터 수행한다.)
>
> 제너레이터 컴프리헨션에 대한 코드가 긴 경우에 제너레이터 함수를 사용한다.
> 제너레이터 함수는 yield문으로 값을 반환한다.


## 4.9 데커레이터

> 하나의 함수를 취해서 또 다른 함수를 반환하는 함수
> 소스 코드를 바꾸지 않고, 사용하고 있는 함수를 수정할 때 사용한다.
> *함수 상속과 비슷한 역할이지만, 데커레이터와 또 다른 함수는 분리되어있다.*
> **@데커레이터_이름**
> **함수 정의**

# 이터레이터, 제너레이터
## 이터레이터
> 순회 / 반복 가능한 객체
> #### 이터레이터 vs 이터러블
> 이터러블 = 반복 가능한 객체의 집합 객체
> 이터레이터 = 이터러블이 순환 가능하도록 next()를 가진 객체


## 제너레이터
> 제너레이터 = 특별한 종류의 이터레이터
> ** 자료구조를 메모리에 생성하지 않기에, 메모리 효율이 좋다. **
> 몸체에 yield가 나타나는 모든 함수


range() 는 제너레이터도 이터레이터도 아니다.

dir을 잘 사용할것!

## 데커레이터

> 하나의 함수를 취해서 또 다른 함수를 반환하는 함수
> 소스 코드를 바꾸지 않고, 사용하고 있는 함수를 수정할 때 사용한다.
> 여러개의 데커레이터를 실행할 때는 실행 순서에 유의한다.
> *함수 상속과 비슷한 역할이지만, 데커레이터와 또 다른 함수는 분리되어있다.*
> **@데커레이터_이름**
> **함수 정의**
> __init__ 과 __call__

> <참고> : https://techbard.tistory.com/2504
