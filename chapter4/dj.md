# Chapter 4 - 파이 크러스트 : 코드 구조

이제부터는 파이썬 구조화에 대해서 배운다.

## 4.1 코멘트 달기: #
코멘트 : 인터프리터에 의해 무시되는 텍스트의 한 부분 #문자부터 그 라인의 끝까지 무시

## 4.2 라인 유지하기: \
라인을 적당한 길이로 유지하기 위해 사용 \를 사용한다면 그 다음 줄도 한 라인처럼 다룬다.

## 4.3 비교하기: if, elif, else
>다른 프로그래밍 언어와는 달리, 파이썬의 if 문에서는 괄호를 사용하지 않는다!

### 파이썬의 들여쓰기
> “Use 4 spaces per indentation level.” pep-8이라고 부르는 파이썬 코드 권장 스타일에서는 들여쓰기 4칸의 스페이스 사용하기를 권장

### 파이썬에서의 False
파이썬에서 Flase로 명시해주는 값

| 요소 | False |
| -----: | -----: |
| 정수 0 | 0 |
| 부동소수점 0 | 0.0 |
| 빈 문자열 | '' |
| 빈 리스트 | [] |
| 빈 튜플 | () |
| 빈 딕셔너리 | {} |
| 빈 셋 | set() |

> 리스트 안에는 리스트를 넣을 수 있는데 리스트 안에 빈 리스트를 넣으면 True로 볼까요 False로 볼까요?

## 4.4 반복하기: while
## 4.4.1 중단하기: break
## 4.4.2. 건너뛰기: continue
## 4.4.3 break 확인하기: else
while  문에도 else문을 사용할 수 있는데 break문이 실행되지 않았을 경우에만 실행된다.

> 함수 안에 break문이 없어도 else 문이 실행될까?

## 순회하기: for
파이썬에서 이터레이터(iteratior)는 유용하게 쓰인다. 자료구조의 크기나 구현 방식에 상관없이 자료 구조를 순회시켜준다. 바로 생성된 데이터 순회도 가능하다. 데이터가 메모리에 맞지 않더라도 데이터 스트림을 처리할 수 있도록 허용한다

'''
x = [1, 2, 3]  #이터레이블(순회가능한)
y = iter(x)  #이터레이블한 x에서 만든 이터레이터
z = iter(x)  #이터레이블한 x에서 만든 이터레이터
next(y)  #1
next(y)  #2
next(z)  #1
type(x)  #<class 'list'>
type(y)  #<class 'list_iterator'>
'''
자료 구조 별 파이썬에서 for문 구동 방식은
> 딕셔너리의 순회는 키를 반환
>> 딕셔너리에서 값을 반환시키고 싶을 경우 values() 이용

> 리스트나 튜플의 순회는 한 항목을 반환
>> 튜플에서 키와 값을 모두 반환하기 위해서는 items() 이용

> 결론 : iterable하다는 것은 순회가 가능하다는 것. iterator는 iterable한 값을 next(), prev() 등을 이용해 직접적으로 이용할 수 있는 객체를 뜻한다.
파이썬의 순회방법은 GET_ITER를 통해 iterator 객체를 호출해 모든 값을 순회하는 방식이다.

## 4.5.1 중단하기: break
## 4.5.2 건너뛰기: continue
## 4.5.3 break 확인하기: else
## 4.5.4 여러 시퀀스 순회하기: zip()
> 시퀀스(sequence)는 데이터에 순서(번호)를 붙여 나열한 것

여러 시퀀스를 병렬로 순회하는 것, 가장 짧은 시퀸스가 완료되면 멈춘다.
zip()을 통해 반환되는 값은 튜플이나 리스트가 아니라 iterable할 수 있는 값이다.

## 4.5.5 숫자 시퀀스 생성하기: range()
**자료구조를 생성하여 저장**하지 않더라도 특정 범위 내에 숫자 스트림을 반환한다.
range()를 통해 반환되는 값도 순회 가능한(iterable)한 객체를 반환한다.

## 4.6 컴프리헨션
하나 이상의 이터레이터로부터 파이썬의 자료 구조를 만드는 방법이다. 비교적 간편하게 반복문과 조건 테스트를 결합할 수 있도록 해준다.

장점
- 코드 자체가 더욱 간결해진다.
- 컴팩트해진다.

왜 사용할까?
> List comprehensions are more compact and faster than an explicit for loop building a list

## 4.6.1 리스트 컴프리헨션
리스트 컴프리헨션의 조건 표현식
> [표현식 for 항목 in 순회 가능한 객체 if 조건]
리스트 컴프리헨션에서는 if 테스트와 다중 for 문을 가질 수 있다.

## 4.6.2 딕셔너리 컴프리헨션
딕셔너리 컴프리헨션의 조건 표현식
> {키_표현식 : 값_표현식 for 표현식 in 순회 가능한 객체}

## 4.6.3 셋 컴프리헨션
셋 컴프리헨션의 조건 표현식
> {표현식 for 표현식 in 순회 가능한 객체}

## 4.6.4
제너레이터는 이터레이터에 **데이터를 제공**하는 하나의 방법이다.
제너레이터 객체로 바로 순환도 가능하며 list()를 사용하여 리스트 컴프리헨션처럼 만들어 줄 수도 있다.

> Note 리스트, 셋 ,문자열, 딕셔너리는 메모리에 존재하지만 제너레이터는 즉석에서 그 값을 생성하고, 이터레이터를 통해서 한 번에 값을 하나씩 처리. 제너레이터가 이 값을 기억하지 않으므로 **다시 시작**하거나 **백업**을 할 수 없다.

## 4.7 함수
함수는 두 가지 작업을 수행한다.
- 정의하기(define)
- 호출하기(call)

인자 : 함수에게 전달한 값.
매개변수 : 인자값을 이용하기 위해 함수 내에서 사용하는 변수

함수의 인자는 개수에 상관없이 모든 타입의 인자를 취할 수 있다. 반환값도 마찬가지로 개수에 상관없이 모든 타입을 반환할 수 있다.

> 만약 함수가 명시적으로 return을 호출하지 않으면, 호출자는 반환값으로 None을 얻는다.

> **None** False 값으로 사용되지만 False 값과는 다르다. 빈 리스트, 빈 문자열, 빈 튜플, 빈 딕셔너리와는 다른 것이다.

## 4.7.1 위치 인자
가장 일반적으로 사용되는 방식, 단점으로는 위치의 의미를 알아야한다.

## 4,7,2 키워드 인자
매개변수에 상응하는 이름을 인자에 지정하는 방식(일반적으로 사용하는 python 함수들에서 사용하는 방식으로 생각된다 + 기본 매개변수 값 지정하기)

> 위치 인자와 키워드 인자로 하수를 호출한다면 위치 인자가 먼저 와야한다.

## 4.7.3 기본 매개변수값 지정하기
매개변수에 기본값을 지정하는 방식, 호출자가 대응하는 인자를 제공하지 않을 경우 기본 값을 사용한다

> 기본 인자값은 함수가 실행될 때 계산되는 것이 아니라, 함수 정의시 계산된다. 변경 가능한 데이터 타입을 기본 인자로 사용하게 되면 문제가 발생한다.

## 4.7.4 위치 인자 모으기: *
 * : 애스터리스크 -> 파이썬에서 사용될 때에는 위치 인자 변수들을 튜플로 묶는다.

## 4.7.5 키워드 인자 모으기: **
키워드 인자를 딕셔너리로 묶기 위해서는 두 개의 애스터리스크(**)를 사용할 수 있다.

> 4.7.4와 4.7.5를 동시에 사용하려면 순서대로 배치를 해야한다.

## 4.7.6 docstring
함수 몸체 시작 부분에 문자열을 포함시켜 함수 정의가 가능하다.

docstring을 출력하려면 help()로 출력할 수 있고 함수 이름을 인자로 전달한다.
서식 없는 docstring을 그대로 보고 싶다면 객체.__doc__ 형식으로 하면 된다.

## 4.7.7 일등 시민: 함수
파이썬에서 함수를 변수에 할당할 수 있고 다른 함수에서 이를 인자로 쓸 수 있으며 함수에서 이를 반환할 수 있다는 뜻(대박)
함수의 값이 아니라 **함수 자체**를 전달할 수 있다.

## 4.7.8  내부 함수
함수 안에 또 다른 함수를 정의할 수 있다.
코드 중복을 피하거나 또 다른 함수 내에 복잡한 작업을 한 번 이상 수행할 때 유용하게 사용된다.

## 4.7.9 클로져
내부 함수는 클로져처럼 행동할 수 있다. 
1. 외부 함수의 변수를 직접 사용한다.
2. 클로져 함수의 이름을 호출하지 않고, 이를 반환한다. -> ()를 붙이지 않는다.

## 4.7.10 익명 함수 : lambda()
단일문으로 표현되는 익명함수
사용 방법 함수 이름(lambda 인자이름 :　함수 정의 부분 )
람다는 많은 작음 함수를 정의하고, 이들을 호출해서 얻은 모든 결과값을 저장해야하는 경우 유용, 특히 콜백 함수 정의하는 그래픽 유저 인터페이스(GUI)에서 람다를 사용할 수 있다.

## 4.8 제너레이터
파이썬의 시퀀스를 생성하는 객체, 전체 시퀀스를 한번에 메모리에 생성하고 정렬할 필요가 없다.<이해x>

## 4.9 데커레이터
하나의 함수를 이용해 또 다른 함수를 반환하는 함수이다.
- *args와 **kwargs
- 내부 함수
- 함수 인자

기존에 사용하던 함수의 일부만 수정해서 사용하고 싶을 경우 이용

## 4.10 네임스페이스와 스코프
지역변수와 전역변수 이용 순서 지역변수를 전역적으로 사용하고 싶다면 global을 붙이면 된다.
globals(), locals()를 통해 네임스페이스 내용에 접근 또한 가능
locals()에서 나오는 네임스페이스는 animal만 있지만 global()에서 나오는 네임스페이스는 다양하다 why?

## 4.10.1 이름에 _와 __사용
잘 안쓸 것 같아서 __ 사용

## 4.11 에러 처리하기: try, except
에러가 발생했을 경우 실행되는 부분
try블록과 except블록으로 나눠지며 try블록 안의 코드를 실행할 때 에러가 있다면 except블록 내의 코드를 실행시킨다.
단순히 except는 모든 예외 타입을 잡는다는 뜻인데, 만약, 두 개 이상의 에러타입이 있다면 각각의 except블록을 만들어주는 것이 좋다. 
에러 타입 as 이름 형식으로 만들면 변수 이름에서 예외 객체 전체를 얻을 수 있다.

## 4.12 예외 만들기
새로운 예외 타입을 정의하려면 클래스 객체 타입을 정의해야한다.