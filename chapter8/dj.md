# 흘러가는 데이터
이번에는 일반 파일, 구조화된 파일, 데이터베이스와 같이 특수 목적에 맡게 최적화된 데이터 스토리지의 각 특징을 살펴본다.

## 8.1 파일 입출력
데이터를 가장 rksseks하게 지속하는 방법 **보통 파일**사용.
> 파일 : 파일 이름으로 저장된 바이트 시퀀스
```python
#사용법
*fileobj* = open(*filename*, *mode*) 
```

|mode|내용|
|r|파일 읽기|
|w|파일 쓰기(파일이 존재하지 않으면 파일을 생성, 존재하면 덮어쓴다)|
|x|파일 쓰기(파일이 존재하지 **않을 경우**에만 해당)|
|a|파일 추가하기(파일이 존재하면 파일의 끝에서부터 쓴다)|
|(두번째글자)t(또는 아무것도 명시하지 않음)|텍스트 타입|
|(두번쨰글자)b|이진 타입|

> 파일을 다 사용했다면, 파일을 닫아야한다!

## 8.1.1 텍스트 파일 쓰기: write()
write() 함수
- 파일에 쓴 바이트 수를 반환한다.
- print()함수처럼 스페이스나 줄바꿈을 추가하지 않는다.

print() 함수로 write()처럼 작동하려면 sep, end 인자를 전달해야한다.
- sep(구분자, 기본값은 스페이스(‘ ’))
- end(문자열 끝, 기본값은 줄바꿈(‘\n’))

파일에 쓸 문자열이 크면 특정 단위로 나누어서 파일에 쓰기도 한다.

## 8.1.2 텍스트 파일 읽기: read(), readline(), readlines()
1. read()
- 함수를 인자 없이 호출하여 한 번에 전체 파일을 읽을 수 있음.
- 메모리가 소비될 수 있으므로 큰 파일을 읽을 때 주의.
- 인자를 통해 한 번에 읽을 수 있는 문자수를 제한 가능
- 파일의 끝에 도달하면, 함수는 빈 문자열을 반환한다.(if 문에서 false)

2. readline()
- 파일을 라인 단위로 읽는다.
- 텍스트 파일의 빈 라인은 1로 책정(‘\n’)
- 파일의 끝에 빈 문자열을 반환한다.

3. 이터레이터(iterator)
- 텍스트 파일을 가장 읽기 쉬운 방법
- 한번에 한 라인씩 반환한다.

4. readlines()
- 한번에 모든 라인을 읽고 한 라인으로 된 문자열들의 리스트를 반환한다.

## 8.1.3 이진 파일 쓰기: write()
모드에 ‘b’를 포함시키면 파일을 이진 모드, 문자열 대신 바이트를 읽고 쓸 수 있음
동작은 텍스트 파일 쓰기와 비슷하게 동작함(단지, 바이트)

## 8.1.4 이진 파일 읽기: read()
모드에 ‘rb’를 쓰면 이진 파일 읽기

## 8.1.5 자동으로 파일 닫기: with
함수 안에 파일을 열어놓고 이를 명시적으로 닫지 않더라도 파이썬에서는 함수가 끝날 때 자동으로 파일을 닫아준다.(단, 오랫동안 작동하는 함수 혹은 메인 프로그램에서 열었다면 명시적으로 닫아야한다)

콘텍스트 매니저(context manager) : 파일을 여는 것과 같은 일을 수행
```python
# 사용법
with open(‘*filename*’, ‘*mode*’) as *variable*
	*variable*.write() 
# 코드 블록의 코드가 시행되고 나서 자동으로 파일을 닫아준다.
```

## 8.1.6 파일 위치 찾기: seek()
파일을 읽고 쓸 때, 파이썬은 파일에서 위치를 추적한다.
- tell() : 파일의 시작으로부터의 현재 오프셋을 바이트 단위로 반환
- seek() : 다른 바이트 오프셋으로 위치를 이동 가능.

seek(*offset*, *origin*)
- *origin*이 0 => 시작 위치에서 *offset* 바이트로 이동
- *origin*이 1 => 현재 위치에서 *offset* 바이트로 이동 (커서)
- *origin*이 2 => 마지막 위치에서 *offset* 바이트 전 위치로 이동(*offset*은 보통 음수)

## 8.2 구조화된 텍스트 파일
텍스트 파일은 라인으로 구성되어 있다. 어떤 프로그램에서 데이터를 저장 또는 다른 프로그램을 보낼 때, 구조화된 데이터가 필요하다. 더 구조화된 텍스트 파일을 알아보자.

대표적인 몇가지 형식
- 탭(‘\t’), 콤마(‘,’), 수직 바(‘|’)와 같은 문자를 구분자로 사용한다. 여기에서는 CSV(Comma-Separated Value)를 다룬다.
- 태그를 ‘<’와 ‘>’로 둘러싼다. 여기에서는 XML(eXtensible markup language)과 HTML(HyperText Markup Language)을 다룬다.
- 구두점을 사용한다. 여기서는 JSON(JavaScript Object Notation)을 다룬다.
- 들여쓰기를 사용한다. 여기에서는 YAML(YAML Ain’t Markup Language)을 다룬다.
- 프로그램 설정 파이과 같은 여러 가지 형식을 사용한다.

## 8.2.1 CSV
CSV: Comma-Separated Values를 뜻하며 주로 데이터베이스에서 많이 사용.

> reader() : CSV 형식의 파일을 쉽게 읽을 수 있다.
기본적으로 reader()와 writer()함수를 사용하면, 열은 콤마로 나누어지고, 행은 줄바꿈 문자로 나누어진다.

> DictReader() : 리스트의 리스트가 아닌 딕셔너리의 리스트로 읽어온다..
> DictWriter() :  딕셔너리로 파일을 집어 넣을 수 있다. 
> writeheader() : 첫 라인에 입력값을 넣는다.

## 8.2.2 XML 
XML : 가장 잘 알려진 마크업 형식, 데이터를 구분하기 위해 **태그**를 사용

데이터 피드와 메시지 전송에 많이 쓰인다. (유연성이 좋은 듯)

XML 라이브러리
xml.dom : DOM은 웹 문서의 계층 구조를 나타냄, 전체 XML파일의 모든 항목에 접근 가능
xml.sax : 죽석에서 MXL을 파싱, 전체 XML파일을 메모리에 로딩하지 않는다. 큰 파일일 때 이용

## 8.2.3 HTML
```python
pass
```

## 8.2.4 JSON
JSON 은 하나의 메인 모듈이 존재하고 데이커 교환하는 아주 인기 있는 형식

isinstance()를 통해 파이썬에서는 모든 함수를 실행할 수 있고 해당 ㄱ밧을 이용해 JSON문자열을 이용한 특수 로직을 만들 수 있다.(파이썬이 객체로 이루어져있기 때문)

## 8.2.5 YAML
키와 값을 가지고 있지만, 날짜와 시간 같은 데이터 타입을 많이 처리.
파이썬에서 표준 라이브러리를 제공하지 않아 써드 파티 라이브러리 설치가 필요.

> safe_load() : 신뢰할 수 없는 YAML을 불러올 때 사용.

## 8.2.6 보안 노트
```python
pass
```

## 8.2.7
프로그램의 다양한 옵션이 존재한다.

자신이 직접 만드는 것보다 configparser 문서를 참고한다.

## 8.2.8 기타 데이터 교환형식

## 8.2.9 직렬화하기: pickle
직렬화 : 자료구조를 파일로 저장하는 것.
파이썬에서는 모든 데이터 타입을 직렬화하는 컨버터가 필요 -> pickle